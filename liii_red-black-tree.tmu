<TMU|<tuple|1.0.5|1.2.9.7>>

<style|<tuple|generic|chinese|goldfish|literate|reduced-margins|python>>

<\body>
  <\hide-preamble>
    <assign|r7rs|<flag|R7RS|dark cyan>>

    <assign|srfi|<flag|SRFI|dark red>>

    <assign|font|math=Latin Modern Math,cjk=Noto CJK SC,CMU>

    <assign|typehint|<macro|body|<goldfish-lang|<arg|body>>>>
  </hide-preamble>

  <chapter|(liii red-black-tree)><label|chapter:liii_alist>

  <section|概述>

  red-black-tree 提供函数式红黑树数据结构接口。

  <section|许可证>

  <\goldfish-chunk|goldfish/liii/red-black-tree.scm|false|true>
    ;

    ; BSD License by Peter Danenberg

    ;

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/red-black-tree.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0my-sqrt

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  \;

  <section|接口>

  <\goldfish-chunk|goldfish/liii/red-black-tree.scm|true|true>
    (define-library (liii red-black-tree)

    (import (liii error))

    (export make-red-black-tree red-black-tree?

            red-black-tree-empty?

            red-black-tree-find red-black-tree-insert

            red-black-tree-delete)

    (begin

    \;
  </goldfish-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/red-black-tree-test.scm|true|true>
    (import (liii red-black-tree) (liii list) (liii check))

    <next-line>

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|实现>

  <paragraph|make-red-black-tree>

  接受一个比较函数，返回一个红黑树。

  比较函数接受两个元素进行比较，根据不同情况返回'eq,'lt或者'gt.

  <\goldfish-chunk|goldfish/liii/red-black-tree.scm|true|true>
    (define (int-cmp x y)

      (cond

        ((= x y) 'eq)

        ((\< x y) 'lt)

        (else 'gt)))

    \;
  </goldfish-chunk>

  <paragraph|red-black-tree-empty?>

  判断红黑树是否为空。

  make-red-black-tree创建的红黑树是空的红黑树。

  <\scm-chunk|tests/goldfish/liii/red-black-tree-test.scm|true|true>
    (check-true (red-black-tree-empty? (make-red-black-tree int-cmp)))

    \;
  </scm-chunk>

  \;

  <paragraph|(red-black-tree-insert tree key val)>

  向红黑树tree中插入键为key值为val的元素，返回修改后的红黑树。

  \;

  构造一个元素为5:5, 8:8, 2:2, 9:9, 3:3, 7:7, 0:0, 1:1, 6:6的红黑树。

  <\goldfish-chunk|goldfish/liii/red-black-tree-test.scm|true|true>
    (define (construct lst)

      (fold-right (lambda (x t) (red-black-tree-insert t x x))

                  (make-red-black-tree int-cmp) lst))

           

    (define elements '(5 8 2 9 3 7 0 1 6))

    (define tree (construct elements))

    \;
  </goldfish-chunk>

  \;

  <paragraph|(red-black-tree-find tree key)>

  在红黑树tree中查找键为key的元素的值，返回该值，若没有找到，返回#f.

  \;

  <subparagraph|测试>

  <\goldfish-chunk|tests/goldfish/liii/red-black-tree-test.scm|true|true>
    (define (construct lst)

      (fold-right (lambda (x t) (red-black-tree-insert t x x))

                  (make-red-black-tree int-cmp) lst))

           

    (define elements '(5 8 2 9 3 7 0 1 6))

    (define tree (construct elements))

    <next-line>

    (for-each (lambda (x) (check (red-black-tree-find tree x) =\> x))\ 

              elements)

    \;
  </goldfish-chunk>

  <subparagraph|(red-black-tree-delete tree key)>

  在红黑树tree中删除键为key的元素，返回被修改的树。

  \;

  删除所有元素后，是一颗空树。

  <\goldfish-chunk|tests/goldfish/liii/red-black-tree-test.scm|true|true>
    (define tree3 (fold-right (lambda (x t) (red-black-tree-delete t x)) tree elements))

    <next-line>

    (check-true (red-black-tree-empty? tree3))

    \;
  </goldfish-chunk>

  删除任意元素，该元素不能被找到，但是其他元素可以被找到。

  <\goldfish-chunk|tests/goldfish/liii/red-black-tree-test.scm|true|true>
    (for-each (lambda (x) (define new-tree (red-black-tree-delete tree x))

                          (check-false (red-black-tree-find new-tree x))

                          (for-each (lambda (y)\ 

                                            (when (not (= x y))

                                                (check (red-black-tree-find new-tree y) =\> y))) elements))\ 

      elements)

    \;
  </goldfish-chunk>

  <section|结束>

  <\goldfish-chunk|goldfish/liii/red-black-tree.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/red-black-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  \;
</body>

<\initial>
  <\collection>
    <associate|font-base-size|12>
    <associate|page-height|auto>
    <associate|page-orientation|landscape>
    <associate|page-screen-margin|false>
    <associate|page-type|a4>
    <associate|page-width|auto>
    <associate|save-aux|false>
  </collection>
</initial>
