<TMU|<tuple|1.0.5|1.2.9.8>>

<style|<tuple|generic|chinese|goldfish|literate|reduced-margins|python>>

<\body>
  <\hide-preamble>
    <assign|r7rs|<flag|R7RS|dark cyan>>

    <assign|srfi|<flag|SRFI|dark red>>

    <assign|font|math=Latin Modern Math,cjk=Noto CJK SC,CMU>

    <assign|typehint|<macro|body|<goldfish-lang|<arg|body>>>>
  </hide-preamble>

  <chapter|(liii scala)>

  <section|许可证>

  <\scm-chunk|goldfish/liii/scala.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    (define-library (liii scala)

    (import (liii string) (liii vector) (liii list))

    (export

    \ \ case-list case-list? case-list=?

    \ \ case-vector case-vector? case-vector=?)

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii scala)

    \ \ \ \ \ \ \ \ (liii cut))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|实现>

  <paragraph|case-list>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    (define-case-class case-list ((data list?))

    \ \ (define (%collect) data)

    \;

    \ \ (define (%map x . xs)

    \ \ \ \ (let1 r (case-list (map x data))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \ \ 

    \ \ (define (%flat-map x . xs)

    \ \ \ \ (let1 r (case-list (flat-map x data))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \ \ 

    \ \ (define (%filter x . xs)

    \ \ \ \ (let1 r (case-list (filter x data))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \;

    \ \ (define (%for-each x)

    \ \ \ \ (for-each x data))

    \;
  </scm-chunk>

  <paragraph|case-list%take>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%take x . xs)

    \ \ \ \ (typed-define (scala-take (data list?) (n integer?))

    \ \ \ \ \ \ (cond ((\<less\> n 0) '())

    \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= n (length data)) data)

    \ \ \ \ \ \ \ \ \ \ \ \ (else (take data n))))

    \;

    \ \ \ \ (let1 r (case-list (scala-take data x))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let ((lst (case-list '(1 2 3 4 5))))

    \ \ (check (lst :take -1 :collect) =\<gtr\> '())

    \ \ (check (lst :take 0 :collect) =\<gtr\> '())

    \ \ (check (lst :take 3 :collect) =\<gtr\> '(1 2 3))

    \ \ (check (lst :take 5 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :take 10 :collect) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </scm-chunk>

  <paragraph|case-list%take-right>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%take-right x . xs)

    \ \ \ \ (typed-define (scala-take-right (data list?) (n integer?))

    \ \ \ \ \ \ (cond ((\<less\> n 0) '())

    \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= n (length data)) data)

    \ \ \ \ \ \ \ \ \ \ \ \ (else (take-right data n))))

    \;

    \ \ \ \ (let1 r (case-list (scala-take-right data x))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let ((lst (case-list '(1 2 3 4 5))))

    \ \ (check (lst :take-right -1 :collect) =\<gtr\> '())

    \ \ (check (lst :take-right 0 :collect) =\<gtr\> '())

    \ \ (check (lst :take-right 3 :collect) =\<gtr\> '(3 4 5))

    \ \ (check (lst :take-right 5 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :take-right 10 :collect) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </scm-chunk>

  <paragraph|case-list%count>

  <\goldfish-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%count . xs)

    \ \ \ \ (cond ((null? xs) (length data))

    \ \ \ \ \ \ \ \ \ \ ((length=? 1 xs) (count (car xs) data))

    \ \ \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "case-list%count" xs))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (check ((case-list (list 1 2 3)) :count) =\<gtr\> 3)

    (check ((case-list (list 1 2 3)) :count (cut \<gtr\> \<less\>\<gtr\> 1)) =\<gtr\> 2)

    \;
  </scm-chunk>

  <subparagraph|fold>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%fold initial f)

    \ \ \ \ (fold f initial data))

    \;

    \ \ (define (%fold-right initial f)

    \ \ \ \ (fold-right f initial data))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let ((lst (case-list '(1 2 3 4 5))))

    \ \ (check (lst :fold 0 +) =\<gtr\> 15)

    \ \ (check (lst :fold '() (lambda (x acc) (cons x acc))) =\<gtr\> '(5 4 3 2 1))

    \;

    \ \ (check (lst :fold-right 0 +) =\<gtr\> 15)

    \ \ (check (lst :fold-right '() (lambda (x acc) (cons x acc))) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </scm-chunk>

  <subparagraph|make-string>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%make-string . xs)

    \ \ \ \ (define (parse-args xs)

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((null? xs) (values "" "" ""))

    \ \ \ \ \ \ \ \ ((length=? 1 xs)

    \ \ \ \ \ \ \ \ \ (let1 sep (car xs)

    \ \ \ \ \ \ \ \ \ \ \ (if (string? sep)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values "" sep "")

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "case-list%make-string: separator must be a string" sep))))

    \ \ \ \ \ \ \ \ ((length=? 2 xs)

    \ \ \ \ \ \ \ \ \ (error 'wrong-number-of-args "case-list%make-string: expected 0, 1, or 3 arguments, but got 2" xs))

    \ \ \ \ \ \ \ \ ((length=? 3 xs)

    \ \ \ \ \ \ \ \ \ (let ((start (car xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (sep (cadr xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (end (caddr xs)))

    \ \ \ \ \ \ \ \ \ \ \ (if (and (string? start) (string? sep) (string? end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values start sep end)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (error 'type-error "case-list%make-string: prefix, separator, and suffix must be strings" xs))))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "case-list%make-string: expected 0, 1, or 3 arguments" xs))))

    \;

    \ \ \ \ (receive (start sep end) (parse-args xs)

    \ \ \ \ \ \ (string-append start (string-join (map object-\<gtr\>string data) sep) end)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let1 l (case-list (list 1 2 3))

    \ \ (check (l :make-string) =\<gtr\> "123")

    \ \ (check (l :make-string " ") =\<gtr\> "1 2 3")

    \ \ (check (l :make-string "[" "," "]") =\<gtr\> "[1,2,3]")

    \ \ 

    \ \ (check-catch 'wrong-number-of-args (l :make-string "[" ","))

    \ \ (check-catch 'type-error (l :make-string 123 "," "]"))

    \ \ (check-catch 'type-error (l :make-string "[" 123 "]"))

    \ \ (check-catch 'type-error (l :make-string "[" "," 123))

    )

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    )

    \;
  </scm-chunk>

  <paragraph|case-vector>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    (define-case-class case-vector ((data vector?))

    \ \ (define (%collect) data)

    \;

    \ \ (define (%map x . xs)

    \ \ \ \ (let1 r (case-vector (vector-map x data))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \ \ 

    \ \ (define (%filter x . xs)

    \ \ \ \ (let1 r (case-vector (vector-filter x data))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \;

    \ \ (define (%for-each x)

    \ \ \ \ (vector-for-each x data))

    \;

    \ \ (define (%count . xs)

    \ \ \ \ (cond ((null? xs) (vector-length data))

    \ \ \ \ \ \ \ \ \ \ ((length=? 1 xs) (vector-count (car xs) data))

    \ \ \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "case-vector%count" xs))))

    \;
  </scm-chunk>

  <paragraph|case-vector%take>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%take x . xs)

    \ \ \ \ (typed-define (scala-take (data vector?) (n integer?))

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((\<less\> n 0) (vector))

    \ \ \ \ \ \ \ \ ((\<gtr\>= n (vector-length data)) data)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ (let ((new-vec (make-vector n)))

    \ \ \ \ \ \ \ \ \ \ \ \ (do ((i 0 (+ i 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= i n) new-vec)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! new-vec i (vector-ref data i)))))))

    \;

    \ \ \ \ (let1 r (case-vector (scala-take data x))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let ((vec (case-vector #(1 2 3 4 5))))

    \ \ (check (vec :take -1 :collect) =\<gtr\> #())

    \ \ (check (vec :take 0 :collect) =\<gtr\> #())

    \ \ (check (vec :take 3 :collect) =\<gtr\> #(1 2 3))

    \ \ (check (vec :take 5 :collect) =\<gtr\> #(1 2 3 4 5))

    \ \ (check (vec :take 10 :collect) =\<gtr\> #(1 2 3 4 5))

    )

    \;
  </goldfish-chunk>

  <paragraph|case-vector%take-right>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%take-right x . xs)

    \ \ \ \ (typed-define (scala-take-right (data vector?) (n integer?))

    \ \ \ \ \ \ (let ((len (vector-length data)))

    \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ ((\<less\> n 0) (vector))

    \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= n len) data)

    \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ (let ((new-vec (make-vector n)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (do ((i (- len n) (+ i 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (j 0 (+ j 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= j n) new-vec)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! new-vec j (vector-ref data i))))))))

    \;

    \ \ \ \ (let1 r (case-vector (scala-take-right data x))

    \ \ \ \ \ \ (if (null? xs) r (apply r xs))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let ((vec (case-vector #(1 2 3 4 5))))

    \ \ (check (vec :take-right -1 :collect) =\<gtr\> #())

    \ \ (check (vec :take-right 0 :collect) =\<gtr\> #())

    \ \ (check (vec :take-right 3 :collect) =\<gtr\> #(3 4 5))

    \ \ (check (vec :take-right 5 :collect) =\<gtr\> #(1 2 3 4 5))

    \ \ (check (vec :take-right 10 :collect) =\<gtr\> #(1 2 3 4 5))

    )

    \;
  </goldfish-chunk>

  <paragraph|case-vector%fold>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%fold initial f)

    \ \ \ \ (vector-fold f initial data))

    \;

    \ \ (define (%fold-right initial f)

    \ \ \ \ (vector-fold-right f initial data))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let ((vec (case-vector #(1 2 3 4 5))))

    \ \ (check (vec :fold 0 +) =\<gtr\> 15)

    \ \ (check (vec :fold '() (lambda (x acc) (cons x acc))) =\<gtr\> '(5 4 3 2 1))

    \;

    \ \ (check (vec :fold-right 0 +) =\<gtr\> 15)

    \ \ (check (vec :fold-right '() (lambda (x acc) (cons x acc))) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </goldfish-chunk>

  <paragraph|case-vector%make-string>

  <\scm-chunk|goldfish/liii/scala.scm|true|true>
    \ \ (define (%make-string . xs)

    \ \ \ \ (define (parse-args xs)

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((null? xs) (values "" "" ""))

    \ \ \ \ \ \ \ \ ((length=? 1 xs)

    \ \ \ \ \ \ \ \ \ (let1 sep (car xs)

    \ \ \ \ \ \ \ \ \ \ \ (if (string? sep)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values "" sep "")

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "case-vector%make-string: separator must be a string" sep))))

    \ \ \ \ \ \ \ \ ((length=? 2 xs)

    \ \ \ \ \ \ \ \ \ (error 'wrong-number-of-args "case-vector%make-string: expected 0, 1, or 3 arguments, but got 2" xs))

    \ \ \ \ \ \ \ \ ((length=? 3 xs)

    \ \ \ \ \ \ \ \ \ (let ((start (car xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (sep (cadr xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (end (caddr xs)))

    \ \ \ \ \ \ \ \ \ \ \ (if (and (string? start) (string? sep) (string? end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values start sep end)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "case-vector%make-string: prefix, separator, and suffix must be strings" xs))))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "case-vector%make-string: expected 0, 1, or 3 arguments" xs))))

    \;

    \ \ \ \ (receive (start sep end) (parse-args xs)

    \ \ \ \ \ \ (string-append start (string-join (map object-\<gtr\>string (vector-\<gtr\>list data)) sep) end)))

    )
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/scala-test.scm|true|true>
    (let1 v (case-vector #(1 2 3))

    \ \ (check (v :count) =\<gtr\> 3)

    \ \ (check (v :count (cut \<gtr\> \<less\>\<gtr\> 1)) =\<gtr\> 2)

    \ \ (check (v :make-string) =\<gtr\> "123")

    \ \ (check (v :make-string " ") =\<gtr\> "1 2 3")

    \ \ (check (v :make-string "[" "," "]") =\<gtr\> "[1,2,3]")

    \ \ 

    \ \ (check-catch 'wrong-number-of-args (v :make-string "[" ","))

    \ \ (check-catch 'type-error (v :make-string 123 "," "]"))

    \ \ (check-catch 'type-error (v :make-string "[" 123 "]"))

    \ \ (check-catch 'type-error (v :make-string "[" "," 123))

    )

    \;
  </goldfish-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/scala.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/scala-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>
</body>

<\initial>
  <\collection>
    <associate|font-base-size|12>
    <associate|page-height|auto>
    <associate|page-orientation|landscape>
    <associate|page-screen-margin|false>
    <associate|page-type|a4>
    <associate|page-width|auto>
    <associate|save-aux|false>
  </collection>
</initial>
